/**
 * BWZ-Rappi - Bank of Rapperswil Backend
 * Das Backend für die Bank of Rapperswil stellt eine vereinfachte API für das Management von Finanz-Transaktionen als Übungsplattform bereit.
 * 
 * OpenAPI spec version: v0.25.2
 * 
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */
 import { inject, Injectable }                   from '@angular/core';
 import { HttpClient, HttpParams }               from '@angular/common/http';
 
 import { Observable }                           from 'rxjs';

import { Transaction } from './dto/transaction';
import { TransactionConfirmation } from './dto/transaction-confirmation';
import { TransactionQuery } from './dto/transaction-query';
import { getOptions, getServerUrl } from './http-environment';

/**
 * Mit dem Transaction Service können Transaktionen durchgeführt werden sowie Abfragen
 * über die getätigten Transaktionen gemacht werden.
 */
@Injectable({providedIn: 'root'})
export class TransactionResourceService {

  private http = inject(HttpClient);

  /**
   * Ruft die Transaktionen des Users, welcher durch das Bearer/JWT Token authentifiziert ist, ab und filtert die Transaktionen gemäss der Parametrisierung.
   * Beschreibung der Query Parameter:
   *   1. Mittels **count** kann die Anzahl der zurückzugebenden Transaktionen bestummen werden.
   *      **skip** bestimmt dabei eine  Anzahl an Transaktionen, welche in der DB übersprungen werden; d.h. diese werden nicht zurückgegeben.
   *      Falls als **count** 0 übergeben wurde, werden alle Einträge zurückgegeben.
   *   2. Mit **startDate** und **endDate** können die Einträge nach Datum gefiltert werden. Dabei sind **startDate** und **endDate** inklusive, d.h. das Filteren erfolgt im 'greater-than-or-equal' und 'less-than-or-equal' Prinzip.
   * 
   * <b>Die API gibt nur bei korrekter Parametrisierung Daten zurück.</b>
   * 
   * Das Resultat enthält die Transaktionen des aktuellen Accounts sowie die parametrisierten Query-Informationen.
   * 
   * @param jwtToken Diese Methode benötigt das JWT Token des aktuell eingeloggten Benutzers (siehe Authentication Service).
   * @param params Spezifiziert das Objekt mit den Query-Daten:
   *   - **startDate** Date-Filter (start), Datum ist inklusive (>=) im ISO-String Format.
   *   - **endDate** Date-Filter (end), Datum ist inklusive (<=) im ISO-String Format.
   *   - **count** Anzahl der zurückzugebenden Resultate.
   *   - **skip** Überspringt die ersten x Resultate.
   * @returns Wichtig: Resultate werden nur zurückgeben, falls count oder startDate und endDate angegeben wurden. Gibt die Transaktions-Informationen für den aktuellen Account inklusiver der Query-Informationen zurück.
   * @example Gibt das Resultat im folgenden Format zurück:
   * ```json
   * {
   *    "query":
   *    {
   *       "resultcount": 107, // Anzahl Results (ohne Filter)
   *       "count": 1,  // Anzahl Resulte welche zurückgegeben werden sollten
   *       "skip": 1, // Überspringt die ersten x Resultate
   *       "startDate": "2025-08-07T14:00:00.000Z",  // Date-Filter
   *       "endDate": "2025-08-11T14:00:00.000Z" // Date-Filter
   *    },
   *    "result":
   *    [
   *       {
   *          "source": "0083 6001 0000 0000 1",
   *          "target": "0083 6001 0000 0000 2",
   *          "amount": -23,
   *          "category": "living",
   *          "newBalance": 977,
   *          "date": "2025-08-10T14:00:00.000Z"
   *       }
   *    ]
   * }
   * ```
   */
  public getTransactions(jwtToken: string, params: { startDate: Date, endDate: Date } | { count: number, skip: number }): Observable<TransactionQuery> {
      let queryParameters = new HttpParams();
      if ('startDate' in params && params.startDate) {
            queryParameters = queryParameters.set('startDate', params.startDate.toISOString());
      }
      if ('endDate' in params && params.endDate) {
          queryParameters = queryParameters.set('endDate', params.endDate.toISOString());
      }
      if ('count' in params && !isNaN(params.count)) {
          queryParameters = queryParameters.set('count', String(params.count));
      }
      if ('skip' in params && !isNaN(params.skip)) {
          queryParameters = queryParameters.set('skip', String(params.skip));
      }
      return this.http.get<TransactionQuery>(
        getServerUrl('/accounts/transactions'),
        getOptions(jwtToken, false, queryParameters));
  }

  /**
   * Überweist den Betrag des Users, welcher durch das Bearer Token
   * authentifiziert ist, auf das spezifizierte Konto.
   * @param jwtToken Diese Methode benötigt das JWT Token des aktuell eingeloggten Benutzers (siehe Authentication Service).
   * @param model Spezifiziert das Konto des Empfängers sowie den zu überweisenden Betrag.
   * @example Gibt das Resultat im folgenden Format zurück:
   * ```json
   * {
   *    "source": "0083 6001 0000 0000 1",
   *    "target": "0083 6001 0000 0000 2",
   *    "amount": -5,
   *    "newBalance": 995,
   *    "date": "2025-07-01T08:48:55.842Z"
   * }
   * ```
   */
  public transfer(jwtToken: string, model: Transaction): Observable<TransactionConfirmation> {
    return this.http.post<TransactionConfirmation>(
      getServerUrl('/accounts/transactions'),
      JSON.stringify(model),
      getOptions(jwtToken));
  }
}
